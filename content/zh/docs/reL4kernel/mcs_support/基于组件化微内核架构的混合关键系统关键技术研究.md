# 基于组件化微内核架构的混合关键系统关键技术研究
## 背景和意义、国内外相关领域的发展、现状与趋势
### 意义
微内核由于其可验证性和高安全性，在嵌入式等设备中具有越来越重要的作用。基于微内核的混合关键系统研究的重要性也愈发凸显。
	
一方面，随着应用的变化，对于微内核提出了更多的实时性和通用性的要求，针对混合关键系统展开深入研究，有助于解决实时系统中高关键性任务和低关键性任务之间的调度难题，提高系统的整体性能和可靠性，本研究对于推动实时系统的发展和应用具有重要意义。
	
另一方面，硬件的发展也要求微内核提供更多的机制，原先在微内核中存在困难的IPC效率问题，以及在混合关键系统中具有重要意义的隔离性，由于缺少硬件的支持，只能采用软件的方案去优化，但是随着硬件的功能的进一步强大，如用户态中断和硬件隔离等技术的发展，也要求微内核进行相应的变化。
	
总之，通过深入探索混合关键系统的关键技术，本研究有望为实时系统的发展提供新的理论支持和实践经验，推动相关领域的技术进步和应用创新。

### 混合关键系统相关研究

混合关键系统（Mixed-Criticality System，简称为MCS）是实时系统的一个分支，自2007年Vestal等[1]提出来之后，便成为实时系统研究中新的重要研究方向之一。
	
混合关键系统的主要思想如下：在一个实时系统中包含不同的任务，他们存在着不同的关键级别，即，不同的任务错过截止日期后所带来的后果是不完全一样的，如在实时车机上，就存在许多关键性安全功能（如动力系统控制，ABS系统等）和非关键性功能（如车载导航系统，音乐等），整个系统的目标应当为，在保证高关键性任务不错过截止时间的前提下，尽最大可能的安排低关键性的任务。

在单核的混合关键系统研究上，最早是Vestal提出了相应的MCS相关的模型，并认为在其所设定的条件下，Audsley的priority assignment算法[2]相比于RM（rate monotonic）和deadline monotonic均更优，该算法在响应时间分析的基础上，以n（n+1）/2的时间复杂度将不同任务放置在多个优先级上。

随后Baruah等[3]给出了单核情况下MCS的AMC通用分析框架，该框架在前述MCS模型的基础上，不仅设定了每个任务的关键级别，也设定了系统能够运行在多个不同的关键级别上，最开始系统在低关键级别按照优先级调度所有任务，当某个任务发生超时时，将系统转换到高关键级别，并在高关键级别下丢弃所有低关键级别任务的运行。这成为了后续混合关键系统研究的通用框架。

在此基础上，EDF-VD算法[4] [5]引入了虚拟截止时间，具体来说，在离线预处理阶段判断是否可调度并生成相应的运行参数k和每个任务的虚拟截止时间，在运行调度期间，如果系统任务的关键级别小于等于k，那么就用该任务的虚拟截止时间运行，否则使用原始截止时间。该方案呈现出来的方案和AMC的框架具有类似的思想。

在多核混合关键系统研究上，其调度算法主要分为三类：全局调度（global Scheduling），分区调度（Partitioned Scheduling）以及半分区调度（semi-partition Scheduling），对于分区调度，实质上和单核的情况下并无太多不同，因此不做介绍。最早的提出对多核的论文是[17]，它提出的MC^2方案，使用了五级的关键性级别，在高关键级别使用分区的单核算法，而低优先级则使用全局的分配方案。

​	值得一提的是，在该论文的后续工作[19]中，对MC^2方案情况下末级缓存和DRAM的隔离性进行了一些分析，并通过页面着色等方案来试图完成隔离。

​	论文[18]开始使用EDF-VD方法研究多核的全局调度方案，其基本框架仍然基于EDF-VD，允许任务在多核上进行任意迁移，并和传统的非MCS的fpEDF全局调度算法进行对比。论文[20]及[21]则使用了一个RUN调度器和他的改进版本GMC-RUN调度器的方案来进行全局调度。

​	对于半分区调度的方案，论文[22]提出了双分区的混合关键性算法DPM，该算法在高关键性模式和低关键性模式下都进行分区，但允许低关键性任务在发生关键性级别切换时，进行有限的迁移以提高资源利用率，除此之外，该论文还在双分区的情况下，对Worst-Fit，Best-Fit，First-Fit三种划分方案共九种组合进行了评估。相比之下，论文[23]对于分区迁移的方案则不同，在某个核心上发生关键性级别切换之后，所有的低关键性任务都会迁移到没有发生关键性级别切换的
其他核心上（如果存在这样的核心）。论文[24]则将半分区的迁移方案和可靠性管理等结合起来。

​	另一种半分区的划分方法则是按照多核所在的cluster进行划分的。例如论文[25]给出了一个在低关键性级别使用更小的cluster而高关键性级别使用大cluster进行调度的方案。

​	在多核情况下，核间的资源竞争会对单个核心上的任务产生未知的影响。前面已经提到过论文[19]针对于末级缓存以及DRAM对多核MCS的影响的相关工作,论文[31]也对DRAM控制器相关的隔离提出了一些建议。

​	论文[26]针对多核MCS系统中，由于总线竞争导致的某个核心上高关键性任务被另一个核心上低关键性任务所延迟的情况进行了分析，并提出了对应的[27]解决方案，该方案对高关键性任务插入若干观察点，以观察该高关键性任务是否能按时完成，并通过分布式的控制方案，控制其他核心的低关键性任务。除此之外，论文[28][29]也对此进行了一些分析，论文[30]将这这种由于多核互相干扰导致的执行速度变慢，抽象为虚拟时间的减速，并基于此进行了分析。

​	当然，除了混合关键系统的算法以外，针对混合关键系统模型本身的各个要素也有各类研究。

​	在关键性级别的数量上，最初的AMC框架只有双关键性级别的分析，而[6][7][8]等论文增加了对离散多关键性级别的分析，尤其是针对航空领域DO-178B等标准所具有的五级关键性级别。除此之外，pWCET[11]提出了WCET的概率分布，而论文[14]等更进一步的将在不同关键级别上的执行时间改为概率分布的执行时间，并以此为基础使用切比雪夫大数定律做出相应的分析，显著提升了MCS系统的吞吐率。

​	在AMC框架下，最初的原文在将系统转换到高优先级之后，不再返回低优先级运行，而[7]则分析了高优先级切换回低优先级的情况,[9]则进一步的使用有向无环图的方式来描述相应的模式切换情况并进行了分析。

​	FMC[10]则针对EDF-VD框架下的关键性切换进行了优化。在EDF-VD模型中，一旦存在高关键性任务超时，则整个系统就被切换到高关键性级别上，但是FMC则提出，只让超时的任务运行在高关键性级别上，这允许高关键性任务的模式切换相互独立，极大的提升了系统资源利用率，对低关键级别的服务质量也有很大提高。后续的论文[12][13]等文献都继续基于此继续改进多核情况下的，进一步在保证高关键性任务的前提下，提升低关键级别的服务质量。

​	除上述的因素之外，一些额外的考虑，比如处理器存在动态频率问题[15]，系统功耗考量[16]等也被添加到MCS系统中。

### rel4微内核及rel4微内核中的MCS方案

​	reL4是seL4微内核的rust重写，其在经过形式化验证的seL4微内核的基础上，采用Rust这一现代语言，以期利用该语言具有的内存安全，高性能高并发和清晰的错误处理等优势，同时使用组件化内核的构建方式，让部分内核组件可供重用。

​	rel4实现的技术方案上，最开始通过保留原有C内核，使用动态链接库的方式将rust的部分和C部分进行拼接，之后将所有C部分均用Rust重写之后，转为一个纯Rust的内核。从最基本的测例支持开始，逐步扩展到所有编译选项均支持的微内核。

​	在原生的seL4微内核中，MCS是一个重要的实时性管理的方案。其具体的实现方案在论文[36]这里被引入，其使用的Sporadic Server算法[37][38]，是传统的基于Server的实时调度技术的一种改进，同时增加了对优先级翻转，TimeOut通信机制等实时相关内容的支持。

​	reL4的实现中为了尽量兼容seL4的内核，也依照seL4内核的设计增加了相应MCS的支持。

### 硬件cache隔离技术

在x86_64，ARM以及riscv等主流平台上，都有最新的硬件cache支持的技术方案。
	
在riscv上，已经有tagged risc-v的支持[33]，该方案通过给地址打tag，从而实现缓存、总线、内存等多个共享资源的隔离。
	
在ARM平台上，在ARMv8.4引入了MPAM硬件机制的支持，该机制以单个CPU为基本的单位，对末级缓存，内存控制单元以及SMMU进行资源访问的控制。论文[34]基于该硬件机制，详细研究了MPAM机制中内存带宽和优先级分区相关的机制并提出了基于该规范的低层次实现和实时分析的所需元素。
	
在x86_64平台上，也有相应的Cache Allocation Technology (CAT)，该技术基于intel的Resource Director Technology（RDT），该技术在cache隔离之外，提供了一系列资源控制能力，包括缓存分配技术(Cache Allocation Technology, CAT)，代码和数据优先级(Code and Data Prioritization, CDP) 以及 内存带宽分配(Memory Bandwidth Allocation, MBA)等。论文[35]对RDT相关的机制及其对实时的影响进行了系统的研究，表明CAT接口有较为满意的结果，但内存带宽分配等其他原语实现仍有较大的改进空间。
	
引入硬件机制进行末级缓存的隔离是重要的，根据论文[40]对执行时间的分析结果，在一个8核平台上，受访存影响，最坏执行时间WCET会增长300%。这对实时性的要求来说是难以接受的。
### 实时性内存分配算法

实时性的内存分配算法主要强调内存分配的实时性，更确切的说是内存分配时延的确定性，当然也需要尽可能的具有较小的内存碎片。
	
最早的相关努力来自于论文[43]，其使用的Half-Fit算法来解决实时性问题。
	
最为经典的要追溯到[32]提出的TLSF算法，该算法使用两级分离适配机制，使用两级的位图来标记空闲块的存在性。从而具有低内存碎片率的特性，更重要的是具有常数的时间复杂度，这提供了相应的确定性。在论文[45]和论文[46]的评估中，TLSF均是最优的实时内存分配算法。
	
论文[39]则从软件层面实现了一个考虑LLC和DRAM Bank的划分物理内存实现资源隔离，并进行内存分配的分配器，并在Linux内核中进行了实现，但在大页映射以及内存总线争用进行隔离上存在缺陷。
	
论文[44]则开始考虑系统缓存并基于系统缓存进行相应的调整，因此在实际实现上，比TLSF更快，不过，其需要知道系统的缓存信息，因此更为复杂。
	
论文[42]基于现代内存测试技术对lemalloc 、 Mimalloc 、 Snmalloc 和 Tcmalloc等多个候选分配器进行测试，并深入分析了其中表现最优的mimalloc分配器，在此基础上提出了RT-mimalloc分配器，继承了mimalloc的无锁架构等优势。该论文对现有的内存分配器的实时化提供了方向。
用户态中断技术
	
在传统的OS中，中断通常只允许发生在内核态。而用户态中断技术，允许在用户态的程序接收中断，这减少了通信的开销。
	
目前intel在x86平台上的用户态中断相关技术已经商用，除此之外，在riscv架构下的N扩展也提供了用户态中断的相关技术并得到了实现[56]。
	
riscv的N扩展，增加了相应的中断相关的寄存器，例如ustatus，utvec，ucause等，同时增加了uret指令用于用户态的返回。用户态中断的现场保存和内核态中断的现场保存基本类似。
	
论文[51]将用户态中断和MPK内存隔离技术相结合，实现了一个用户空间的调度器uProcess。论文[48]则在Linux的框架下，使用用户空间的定时器中断来实现用户态调度框架，相比于其他的调度框架具有显著的优势。论文[49]分别扩展了Caladan和Go运行时，使用用户态中断进行抢占式的用户态调度。表明使用用户态中断的性能显著优于信号和大部分情况下优于编译器插装技术。论文[52]则在现有的intel提供的硬件中断机制的基础上，扩展了其硬件中断的原语，提供跟踪中断、硬件安全点、内核旁路计时器和中断转发等功能，并在模拟中表明其具有更高的性能。

### 组件化内核架构技术

组件化内核，顾名思义，就是使用组件化的方式来构造内核。它将操作系统的核心——内核，视为一项复杂的软件工程并使用组件化的思想进行编写。在这一过程中，我们打破了传统内核开发的界限，让各个组件独立开来编写，使得程序员能够如同编写普通程序般自如地编写内核模块，极大地提升了开发的灵活性与效率。
	
OSKit[47]是犹他大学开发的提供了一个框架和一组模块化的，具有简单接口的库，和一组可重用的OS组件。库操作系统[53]的思想为后来的unikernel提供了思路，现有的库操作系统往往基于虚拟化技术来实现。MirageOS[55]使用OCaml统一编写Unikernel及相应的应用程序，而Unikraft[54]以微库的形式提供一系列具有操作系统功能的模块，并通过对这些库的组合来形成专用的Unikernel。

组件化操作系统的意义在于，能够让操作系统的模块一次编写多次使用，从而极大地减少了“重复造轮子”的负担，也使得相关的操作系统编写人员无需懂得整个系统的方方面面就可以进一步的开发操作系统。
## 课题主要研究内容

本课题主要针对现有在微内核中实现灵活且强隔离的混合关键系统的不足，结合最新的硬件机制，提升微内核的实时性和性能

### 现有工作的不足
 - 微内核性能的不足
现有的微内核存在性能上的不足，这种不足来自于多个原因：
1、IPC的消息传递开销。相比于最初的微内核设计，增加了寄存器传消息等方式来改进IPC性能，但是，跨地址空间的消息传递的开销在现有的硬件发展情况下仍然是巨大的。
2、用于安全的额外维护的数据结构开销。微内核相比于宏内核提供了更好的安全性和隔离性，但这带来额外的数据结构的维护开销。以sel4为例，它存在一个capability机制，内核的所有内核对象都被capability构成的cspace所维护，这带来了额外的开销。
3、内核服务的隔离开销。宏内核下的诸多内核服务，在微内核下被切分为处于多个进程（线程）中的用户程序，原本处于同一个地址空间的内核数据，可能在多个程序中各自维护多个副本并需要及时同步；原本同步的过程调用，现在变成不同程序之间的异步通信等等。隔离的设计本身带来了组件间的开销。
 - MCS实时性和通用性的平衡
在传统的混合关键系统设计中，往往需要设计为一个专用的实时系统并经过精确且代价巨大的前期静态分析。但是随着更为广泛的车用操作系统等兼顾实时性和通用性的需求的提出，需要在满足系统的实时性的同时，更进一步的满足其通用性的需求，支持更多的通用APP。
现有的方案通常使用一个实时内核和通用内核（如Linux）混合使用，从而兼顾两者。但是这往往带来一定内核间通信成本，系统实现的复杂性等问题。
 - sel4微内核MCS方案的不足	
由于rel4微内核本身基于sel4实现，所以rel4的mcs方案也是基于sel4实现的。
虽然rel4所基于的sel4使用了MCS（Mixed-Criticality System）来描述其这一特性，但是其基于Sporadic Server的算法实现并不能称之为真正的MCS。Sporadic Server算法实质上是一种partitioned的算法，它将实时性的周期任务，和其他基于server的任务所占用的CPU带宽区分开来，彼此不能相互干扰。

对于高关键性级别的实时性周期任务，SS算法虽然能保证其实时性，但并不试图区分该任务处于不同关键级别条件下的WCET，从而造成在进行静态分析的时候，对于高关键性级别的分析都基于其设定的单一WCET进行分析，容易导致系统效率不高等问题。

从微内核的实现来说，该方案把一个Sporadic Server的策略放入了内核中，而这和微内核所期望的策略与机制分离的设计准则相违背。这也是一个巨大的缺陷。
 - 混合关键系统设计中对硬件隔离的不足
现有的混合关键系统中，对于同一任务在不同关键级别上的最坏运行时间WCET都有一个估计，并基于该估计进行相应的混合关键系统的设计。

但是这些估计往往也需要考虑实际运行的硬件，比如前面提到的处理器存在动态频率问题，系统功耗考量等，都已有一定的研究，不过，在微内核下实施混合关键系统，由于cache污染，总线资源竞争等问题，当系统运行起来之后，其对于任务的WCET的估计往往是不准确的。这甚至导致了即使使用了多核的处理器，也往往简单的禁用除了一个内核之外的其他核心，不能充分利用所有的处理器资源，即"one-out-of-m"问题[19]。

必须指出的是，在论文[19]中包含了对某个特定的混合关键系统（MC^2）的cache隔离性的分析，这在混合关键系统的综述中已有提及，它通过缓存着色等方案来隔离，除此之外，论文[26][27][28]等也有相关的研究。因此，通过硬件方案增强隔离性在混合关键系统中并非一个新课题。

但是在上述的论文发表时，尚未有直接硬件支持的cache隔离，因此如何利用最新的硬件cache隔离机制进行隔离，是值得研究的新问题。

#### 本课题研究内容
 - 支持MCS的组件化微内核系统设计与实现

本研究使用组件化的方法，改写现有的rel4微内核。现有的rel4组件化微内核的方案，虽然粗糙的将内核分为了common，cspace，vspace等模块，但是仍然存在一定的组件间循环依赖，这通过ffi的方法让上层模块直接调用下层模块，形成了循环依赖，除此之外，出于工程快速迭代的角度快速开发，使得各个组件的可复用性不够优秀，目前的模块划分也需要重新整理。

另一方面，针对现有的reL4微内核的MCS方案内嵌进内核的情况，本课题将在原有的mcs方案之外，设计一个无策略的通用进程时间片管理方案，将调度方案组件化，让各类不同的混合关键系统调度策略均可用于调度决策。

 - 灵活的用户态混合关键系统调度方案
针对现有rel4内核的MCS方案的不足，本课题充分利用用户态中断等硬件条件，以及在微内核下独有的快速切换到目标进程的内核旁路通信机制，将组件化微内核中的混合关键系统各类调度算法，放到用户态的调度策略中，实现既可以放在内核又可以放在用户态的灵活调度方案

用户态中断方式允许在用户态接到中断，尽管调度器切换地址空间仍然需要进入内核且开销巨大，但是相比而言，内核态调度器在每次发生中断都需要进入内核，但大多数时钟中断都会回到原进程，使用用户态中断可以减少相关用户态和内核态的切换开销。

在微内核中实现用户态调度也有其特有的优势，在Linux等通用操作系统环境下，通常难以直接指定下一个运行的进程，但是在rel4中，可以通过特有的IPC通信机制，不经过内核调度器而通过一些旁路方法指定下一个进程作为通信对象，从而直接指定下一个进程。

当然，调度策略本身完全可以以组件化的方式放在内核态，放在用户态只是用于验证其策略的灵活性。
 - 基于处理器级硬件隔离机制的性能隔离方法
针对混合关键系统中的硬件cache隔离不足，本课题基于arm的MPAM以及riscv的tagged riscv等硬件方案，新增相应的capability，通过内核对cache资源进行分区管理。同时，本研究也期望该隔离机制按照组件化的思想，被配置为可选的系统组件，以增强其灵活性。

本课题创新点
1、创新性的使用了最新的用户态中断等硬件特性，在组件化微内核rel4的基础上增加用户态中断等技术来实现用户态调度。
2、在微内核下使用组件化的调度策略，提升微内核的灵活性。
3、创新性的使用tagged riscv和Arm MAPM等硬件隔离方案，进一步的提升实时系统下的隔离性。

### 研究方法

#### 已有的工作
1.已经基于sel4内核实现了主要功能的rust重构，即rel4微内核，目前已经通过sel4的riscv6和aarch64的基础测例。
2.在上述的rel4微内核的实现基础以及sel4给出的Sporadic Server基础上，已经实现了rel4微内核的MCS特性。
3.以seL4微内核和第三方rust-sel4用户态库为基础，使用运行时动态重写syscall指令方案，将用户态的syscall转为IPC，以支持linux环境下的用户态程序运行，目前已经实现了部分linux syscall支持的用户态测例。
4.已将上述的在seL4环境下开发的用户态测例，移植到reL4上并全部成功运行。

#### 拟采用的研究方案
本课题首先实现了syscall转IPC的工作，通过一定的linux测试样例。在此基础上需要改写rel4的capability及相关数据结构和算法，根据研究内容，需要改写以下三部分：
1、增加硬件隔离。增加使用tagged riscv或者MPAM相关的capability，并编写相关的用户态测例进行测试。
2、增加用户态中断管理。首先设计基于用户态中断的capability，并加入内核。其次基于这些capability，设计对应的用户态IPC方案，提升IPC性能。
3、改写MCS。首先依赖现有的内核MCS特性，借助调度相关微内核的系统调用，实现用户态的调度，在这一步，对于内核MCS特性，只将他当做一个计时器来处理。其次基于该用户态调度，进一步的去除内核中的Sporadic Server的策略，而只当做一个计时器。并通过相关的验证，验证相应的混合关键系统的实时性和高可调度性。

其次，本课题需要将rel4微内核进一步的组件化。这首先需要分析现有组件的依赖关系，基于现有的粗糙的组件划分，进一步的根据其特点，将rel4微内核重新拆分成多个高可复用性的组件。
### 关键难点和拟采取的解决措施
##### 用户态调度器的实现
​	传统的操作系统调度器都运行在内核态，seL4内核的原生调度器也运行在内核态。传统的用户态调度器主要针对于用户态线程的管理，但是由于缺少在用户态中断的机制，因此缺少对用户态线程的时间片管理等内容。在增加了用户态中断之后，在用户态可以接到某个中断，从而在中断处理结束的时候，允许进行调度。但是由于地址空间切换只能在内核态实现，因此，需要内核给出相应的机制来完成切换，这是用户态中断实现的难点。
​	之前的用户态中断工作基于Linux等通用内核，通常需要内核“看到”用户态调度器的一些数据来执行对应的策略，从而在内核态的程序按照策略辅助切换到对应的地址空间。reL4内核只使用了少数几个syscall，其中只有一个是真正向内核发起系统调用，并根据对应寄存器参数进行处理，剩下的syscall都是用于各种高效的进程间通信的机制，通过类似于内核旁路的机制，快速的向目标进程发起切换。因此，可以根据rel4微内核的特点，针对性的直接用进程间通信的机制，按照用户态调度器的策略，实现用户态的进程切换过程。

##### 硬件隔离的多核实现

根据文献的调研情况，末级缓存污染等隔离性问题主要出现在多核环境下，从而影响系统的可调度性，使用硬件机制可以避免这种问题，但是需要设计好，多核对硬件cache的使用情况。除此之外，还需要考虑混合关键系统的语义，对于最简单的双关键性级别的情形，高关键性的任务必须独占式地使用cache，以保证其WCET，低关键性的任务则相反。但在多核情况下，每个核心是否发生关键性级别的转换，是难以确定的，这是一个巨大的难点。
​	对于这个问题，我们设计了完全分区方案和半分区方案，对于完全分区方案，每个核心都被固定的分配到某些cache上，彼此互相独立。至于半分区方案，则根据每个核心的关键性级别动态的调整。

### 论文工作总体日程安排
| 时间            | 工作计划                                                     | 产出                         |
| --------------- | ------------------------------------------------------------ | ---------------------------- |
| 2025.6至2025.12 | 1）对本论文提出的设计进行完善<br/>2）完成所有代码实现<br/>3) 设计测试用例确保基本功能正常实现 | 完整可运行的代码             |
| 2026.1至2026.3  | 1）对本论文提出的设计和实现进行实验 对照评估，包括:<br/>a) 性能评估<br/>b) 实时性评估<br/>c) 确定性评估 | 给出完整的论文设计和实验分析 |
| 2026.3至2026.6  | 1）对论文进行总结，优化与修改<br/> 2) 制作汇报演示文档       | 最终论文及答辩演示文稿       |


## 参考文献
[1]preemptive scheduling of multi-criticality systems with Varying Degrees of Execution Time Assurance
[2]On priority assignment in fixed priority scheduling
[3]Response-time analysis for mixed criticality systems
[4]Preemptive Uniprocessor Scheduling of Mixed-Criticality Sporadic Task Systems
[5]Mixed-criticality scheduling of sporadic task systems
[6]Extending mixed criticality scheduling
[7]State-based mode switching with applications to mixed criticalit systems
[8]Bounding and shaping the demand of generalized mixed-criticality sporadic task systems
[9]Schedulability analysis of a graph-based task model for mixed-criticality systems
[10]Utilization-based scheduling of flexible mixed-criticality real-time tasks
[11]Statistical analysis of WCET for scheduling
[12]Efficient runtime slack management for EDF-VD-based mixed-criticality scheduling
[13]EDF-VD scheduling of flexible mixed-criticality system with multiple-shot transitions
[14]Improving the Timing Behaviour of Mixed-Criticality Systems Using Chebyshev’s Theorem
[15] Mixed-criticality scheduling upon varying-speed processors
[16]Energy efficient DVFS scheduling for mixed-criticality systems
[17]Mixed-Criticality Real-Time Scheduling for Multicore Systems
[18]Global mixed-criticality scheduling on multiprocessors
[19]Cache Sharing and Isolation Tradeoffs in Multicore Mixed-Criticality Systems
[20]Adaptation of RUN to mixed-criticality systems
[21]Generalized mixed-criticality scheduling based on RUN
[22]Enhanced partitioned scheduling of Mixed-Criticality Systems on multicore platforms
[23]Semi-partitioned model for dual-core mixed criticality system
[24]Tolerating permanent faults with low-energy overhead in multicore mixed-criticality systems
[25]Cluster-based multicore real-time mixed-criticality scheduling
[26]Monitoring on-line timing information to support mixed-critical workloads
[27]Distributed run-time WCET controller for concurrent critical tasks in mixed-critical systems
[28]Memory Access Control in Multiprocessor for Real-Time Systems with Mixed Criticality
[29] Multicore in real-time systems–temporal isolation challenges due to shared resources
[30]Virtual Timing Isolation for Mixed-Criticality Systems
[31]A predictable and command-level priority-based DRAM controller for mixed-criticality systems
[32]TLSF: a new dynamic memory allocator for real-time systems
[33]https://taggedriscv.readthedocs.io/zh-cn/latest/index.html
[34]Analyzing Arm's MPAM From the Perspective of Time Predictability
[35]A Closer Look at Intel Resource Director Technology (RDT)
[36]Scheduling-Context Capabilities
[37]Aperiodic Task Scheduling  for Hard-Real-Time Systems
[38]Defects of the POSIX Sporadic Server and How to Correct Them
[39]PALLOC: DRAM bank-aware memory allocator for performance isolation on multicore platforms
[40]Worst case delay analysis for memory interference in multicore systems
[41]Unikraft: fast, specialized unikernels the easy way
[42]RT-Mimalloc: A New Look at Dynamic Memory Allocation for Real-Time Systems
[43]An algorithm with constant execution time for dynamic storage allocation
[44]CAMA: Cache-Aware Memory Allocation for WCET Analysis
[45]A constant-time dynamic storage allocator for real-time systems
[46]Memory management: Challenges and techniques for traditional memory allocation algorithms in relation with today's real time needs
[47]The Flux OSKit: A Substrate for Kernel and Language Research
[48]LegoOS: A Disseminated, Distributed OS for Hardware Resource Disaggregation
[49]Skyloft: A General High-Efficient Scheduling Framework  in User Space
[50]The Benefits and Limitations of User Interrupts for Preemptive Userspace Scheduling
[51]Fast core scheduling with userspace process abstraction
[52]Extended User Interrupts (xUI): Fast and Flexible Notification without Polling
[53]Exokernel: An operating system architecture for application-level resource management
[54]Unikraft: Fast, specialized unikernels the easy way
[55]Unikernels: Library operating systems for the cloud
[56]https://github.com/U-interrupt/uintr?tab=readme-ov-file
